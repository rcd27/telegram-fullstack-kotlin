---
alwaysApply: true
description: Общие правила написания на Kotlin
---

## Архитектурные принципы

- **Domain-Driven Design (DDD):**
  - Вся бизнес-логика должна быть инкапсулирована в доменных моделях и сервисах.
  - Строгое разделение слоёв: Domain, Application, Infrastructure, API.
  - Внешние зависимости (БД, очереди, сторонние сервисы) инкапсулируются через порты/интерфейсы (Hexagonal/Onion architecture).

- **Functional First:**
  - Используй неизменяемые (val) структуры данных по умолчанию.
  - Предпочитай чистые функции, избегай побочных эффектов.
  - Используй функции высшего порядка, композицию, map/flatMap, sealed-классы для моделирования вариантов.
  - Ошибки и валидация — через типы, а не через исключения.

- **Railway Oriented Programming (ROP):**
  - Все бизнес-функции возвращают тип Result/Validated/Either (например, sealed class Result<out E, out V>).
  - Используй цепочки обработки (pipeline), где каждая стадия может вернуть ошибку или успех.
  - Не используй throw/catch для бизнес-ошибок — только для truly exceptional situations.
  - Для вдохновения: [fsharpforfunandprofit.com/rop](https://fsharpforfunandprofit.com/rop/)

## Тестирование

- **e2e-тесты — приоритет №1:**
  - Любая новая фича или багфикс должны сопровождаться e2e-тестом, покрывающим сценарий целиком.
  - e2e-тесты должны быть максимально изолированы, быстры и детерминированы.
  - Покрытие e2e — не менее 80% критических бизнес-процессов.

- **Unit/Integration:**
  - Unit-тесты обязательны для сложной бизнес-логики (особенно pure-функций).
  - Интеграционные тесты — для проверки взаимодействия с инфраструктурой (БД, очереди, внешние API).

## Стиль и соглашения

- **Kotlin:**
  - Используй idiomatic Kotlin (extension-функции, data/sealed классы, when, smart-casts).
  - Не используй var без крайней необходимости.
  - Предпочитай выражения (expression) вместо операторов (statement).
  - Используй value class для оборачивания примитивов в бизнес-логику.

- **Документирование:**
  - Документируй публичные API и доменные модели.
  - Для сложных функций — краткое описание входов/выходов и возможных ошибок (через sealed классы).

- **Ошибки и валидация:**
  - Все ошибки — через sealed class, никакой магии с null/Optional.
  - Валидация — отдельными функциями, возвращающими Result/Validated.
  - Использовать Arrow (Either, Validated, etc.) для моделирования ошибок и успеха.

- **Конфигурация:**
  - Только через environment variables или конфиг-файлы, никаких magic numbers.

## CI/CD и качество

- **Линтинг и форматирование:**
  - Используй ktlint/Detekt, не коммить код с ошибками линтера.
- **Проверка тестов:**
  - Перед мержем — все тесты (e2e, unit, integration) должны проходить.
- **Покрытие:**
  - Покрытие unit+e2e — не менее 80% по критическим модулям.

## Пример структуры (feature-based, как в Pantheon)

```
backend/
  features/
    user/
      domain/
        model/
        service/
        event/
      application/
        usecase/
        dto/
      infrastructure/
        repository/
        messaging/
        external/
      api/
        controller/
        route/
      test/
        e2e/
        unit/
        integration/
    chat/
      domain/
      application/
      infrastructure/
      api/
      test/
    payment/
      domain/
      application/
      infrastructure/
      api/
      test/
  common/
    domain/
    application/
    infrastructure/
    api/
    test/
```

**Пояснения:**
- Каждая фича (user, chat, payment и т.д.) инкапсулирует свои доменные модели, сервисы, usecase, инфраструктуру, API и тесты.
- Общие компоненты (например, shared-классы, утилиты, базовые абстракции) выносятся в `common/`.
- Внутри каждой фичи сохраняется DDD-структура: domain, application, infrastructure, api, test.
- Такой подход облегчает масштабирование, изоляцию и повторное использование кода.

---

## TL;DR

- DDD, функциональный стиль, Railway Oriented Programming.
- Ошибки — только через типы, никакого throw/catch.
- e2e — must have, покрытие >80%.
- Чистый, идиоматичный Kotlin.
- Вся инфраструктура — через порты/интерфейсы.
- Линтинг, тесты, покрытие — строго обязательно.

- Чистый, идиоматичный Kotlin.
- Вся инфраструктура — через порты/интерфейсы.
- Линтинг, тесты, покрытие — строго обязательно.


# Правила для backend (Kotlin, DDD, ROP, e2e-first)

## Архитектурные принципы

- **Domain-Driven Design (DDD):**
  - Вся бизнес-логика должна быть инкапсулирована в доменных моделях и сервисах.
  - Строгое разделение слоёв: Domain, Application, Infrastructure, API.
  - Внешние зависимости (БД, очереди, сторонние сервисы) инкапсулируются через порты/интерфейсы (Hexagonal/Onion architecture).

- **Functional First:**
  - Используй неизменяемые (val) структуры данных по умолчанию.
  - Предпочитай чистые функции, избегай побочных эффектов.
  - Используй функции высшего порядка, композицию, map/flatMap, sealed-классы для моделирования вариантов.
  - Ошибки и валидация — через типы, а не через исключения.

- **Railway Oriented Programming (ROP):**
  - Все бизнес-функции возвращают тип Result/Validated/Either (например, sealed class Result<out E, out V>).
  - Используй цепочки обработки (pipeline), где каждая стадия может вернуть ошибку или успех.
  - Не используй throw/catch для бизнес-ошибок — только для truly exceptional situations.
  - Для вдохновения: [fsharpforfunandprofit.com/rop](https://fsharpforfunandprofit.com/rop/)

## Тестирование

- **e2e-тесты — приоритет №1:**
  - Любая новая фича или багфикс должны сопровождаться e2e-тестом, покрывающим сценарий целиком.
  - e2e-тесты должны быть максимально изолированы, быстры и детерминированы.
  - Покрытие e2e — не менее 80% критических бизнес-процессов.

- **Unit/Integration:**
  - Unit-тесты обязательны для сложной бизнес-логики (особенно pure-функций).
  - Интеграционные тесты — для проверки взаимодействия с инфраструктурой (БД, очереди, внешние API).

## Стиль и соглашения

- **Kotlin:**
  - Используй idiomatic Kotlin (extension-функции, data/sealed классы, when, smart-casts).
  - Не используй var без крайней необходимости.
  - Предпочитай выражения (expression) вместо операторов (statement).
  - Используй value class для оборачивания примитивов в бизнес-логику.

- **Документирование:**
  - Документируй публичные API и доменные модели.
  - Для сложных функций — краткое описание входов/выходов и возможных ошибок (через sealed классы).

- **Ошибки и валидация:**
  - Все ошибки — через sealed class, никакой магии с null/Optional.
  - Валидация — отдельными функциями, возвращающими Result/Validated.
  - Использовать Arrow (Either, Validated, etc.) для моделирования ошибок и успеха.

- **Конфигурация:**
  - Только через environment variables или конфиг-файлы, никаких magic numbers.

## CI/CD и качество

- **Линтинг и форматирование:**
  - Используй ktlint/Detekt, не коммить код с ошибками линтера.
- **Проверка тестов:**
  - Перед мержем — все тесты (e2e, unit, integration) должны проходить.
- **Покрытие:**
  - Покрытие unit+e2e — не менее 80% по критическим модулям.

## Пример структуры (feature-based, как в Pantheon)

```
backend/
  features/
    user/
      domain/
        model/
        service/
        event/
      application/
        usecase/
        dto/
      infrastructure/
        repository/
        messaging/
        external/
      api/
        controller/
        route/
      test/
        e2e/
        unit/
        integration/
    chat/
      domain/
      application/
      infrastructure/
      api/
      test/
    payment/
      domain/
      application/
      infrastructure/
      api/
      test/
  common/
    domain/
    application/
    infrastructure/
    api/
    test/
```

**Пояснения:**
- Каждая фича (user, chat, payment и т.д.) инкапсулирует свои доменные модели, сервисы, usecase, инфраструктуру, API и тесты.
- Общие компоненты (например, shared-классы, утилиты, базовые абстракции) выносятся в `common/`.
- Внутри каждой фичи сохраняется DDD-структура: domain, application, infrastructure, api, test.
- Такой подход облегчает масштабирование, изоляцию и повторное использование кода.

---

## TL;DR

- DDD, функциональный стиль, Railway Oriented Programming.
- Ошибки — только через типы, никакого throw/catch.
- e2e — must have, покрытие >80%.
- Чистый, идиоматичный Kotlin.
- Вся инфраструктура — через порты/интерфейсы.
- Линтинг, тесты, покрытие — строго обязательно.

- Чистый, идиоматичный Kotlin.
- Вся инфраструктура — через порты/интерфейсы.
- Линтинг, тесты, покрытие — строго обязательно.
